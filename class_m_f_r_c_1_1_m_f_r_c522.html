<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MFRC522: MFRC::MFRC522&lt; SPI &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MFRC522
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_m_f_r_c_1_1_m_f_r_c522.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_m_f_r_c_1_1_m_f_r_c522-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MFRC::MFRC522&lt; SPI &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_m_f_r_c522_8hpp_source.html">MFRC522.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a297921e5955751817b53b95b34b23d63"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a297921e5955751817b53b95b34b23d63">MFRC522</a> (const uint8_t chipSelectPin, const uint8_t resetPowerDownPin, SPI spiClass, const SPISettings spiSettings=SPISettings(SPI_CLOCK_DIV4, MSBFIRST, SPI_MODE0))</td></tr>
<tr class="separator:a297921e5955751817b53b95b34b23d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5c7485784b98763c33e7da9d2f7c62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a7c5c7485784b98763c33e7da9d2f7c62">MFRC522</a> ()</td></tr>
<tr class="separator:a7c5c7485784b98763c33e7da9d2f7c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be478d423220af7b54db63c362a6902"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a6be478d423220af7b54db63c362a6902">PCD_WriteRegister</a> (<a class="el" href="namespace_m_f_r_c.html#a2da467e59aa8c879edcc6aa3c9209638">PCDRegister</a> reg, uint8_t value)</td></tr>
<tr class="memdesc:a6be478d423220af7b54db63c362a6902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a byte to the specified register in the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> chip.  <a href="#a6be478d423220af7b54db63c362a6902">More...</a><br/></td></tr>
<tr class="separator:a6be478d423220af7b54db63c362a6902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087518df749ac13980f1b7aa075350d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a087518df749ac13980f1b7aa075350d2">PCD_WriteRegister</a> (<a class="el" href="namespace_m_f_r_c.html#a2da467e59aa8c879edcc6aa3c9209638">PCDRegister</a> reg, uint8_t count, uint8_t *values)</td></tr>
<tr class="memdesc:a087518df749ac13980f1b7aa075350d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a number of bytes to the specified register in the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> chip.  <a href="#a087518df749ac13980f1b7aa075350d2">More...</a><br/></td></tr>
<tr class="separator:a087518df749ac13980f1b7aa075350d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a393a1dff186ad19d31f9e02ee4e78"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a31a393a1dff186ad19d31f9e02ee4e78">PCD_ReadRegister</a> (<a class="el" href="namespace_m_f_r_c.html#a2da467e59aa8c879edcc6aa3c9209638">PCDRegister</a> reg)</td></tr>
<tr class="memdesc:a31a393a1dff186ad19d31f9e02ee4e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a byte from the specified register in the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> chip.  <a href="#a31a393a1dff186ad19d31f9e02ee4e78">More...</a><br/></td></tr>
<tr class="separator:a31a393a1dff186ad19d31f9e02ee4e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9649953537c252a9572b8d843c3646ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a9649953537c252a9572b8d843c3646ca">PCD_ReadRegister</a> (<a class="el" href="namespace_m_f_r_c.html#a2da467e59aa8c879edcc6aa3c9209638">PCDRegister</a> reg, uint8_t count, uint8_t *values, uint8_t rxAlign=0)</td></tr>
<tr class="memdesc:a9649953537c252a9572b8d843c3646ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number of bytes from the specified register in the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> chip.  <a href="#a9649953537c252a9572b8d843c3646ca">More...</a><br/></td></tr>
<tr class="separator:a9649953537c252a9572b8d843c3646ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67c3d632e2cd9f02c79d5ab04e3b6d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#ae67c3d632e2cd9f02c79d5ab04e3b6d7">PCD_SetRegisterBitMask</a> (<a class="el" href="namespace_m_f_r_c.html#a2da467e59aa8c879edcc6aa3c9209638">PCDRegister</a> reg, uint8_t mask)</td></tr>
<tr class="memdesc:ae67c3d632e2cd9f02c79d5ab04e3b6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a bitwise OR on the given register.  <a href="#ae67c3d632e2cd9f02c79d5ab04e3b6d7">More...</a><br/></td></tr>
<tr class="separator:ae67c3d632e2cd9f02c79d5ab04e3b6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b4606785e6d0fac5de0b7c5c33634b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#aa4b4606785e6d0fac5de0b7c5c33634b">PCD_ClearRegisterBitMask</a> (<a class="el" href="namespace_m_f_r_c.html#a2da467e59aa8c879edcc6aa3c9209638">PCDRegister</a> reg, uint8_t mask)</td></tr>
<tr class="memdesc:aa4b4606785e6d0fac5de0b7c5c33634b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the bits given in mask from register reg.  <a href="#aa4b4606785e6d0fac5de0b7c5c33634b">More...</a><br/></td></tr>
<tr class="separator:aa4b4606785e6d0fac5de0b7c5c33634b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1993a4ebe1f303f2ade7ca51da3e6771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a1993a4ebe1f303f2ade7ca51da3e6771">PCD_CalculateCRC</a> (uint8_t *data, uint8_t length, uint8_t *result)</td></tr>
<tr class="memdesc:a1993a4ebe1f303f2ade7ca51da3e6771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the CRC coprocessor in the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> to calculate a CRC_A.  <a href="#a1993a4ebe1f303f2ade7ca51da3e6771">More...</a><br/></td></tr>
<tr class="separator:a1993a4ebe1f303f2ade7ca51da3e6771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7977fc7aca1707b43acec4d7a10239fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a7977fc7aca1707b43acec4d7a10239fe">PCD_Init</a> ()</td></tr>
<tr class="memdesc:a7977fc7aca1707b43acec4d7a10239fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> chip.  <a href="#a7977fc7aca1707b43acec4d7a10239fe">More...</a><br/></td></tr>
<tr class="separator:a7977fc7aca1707b43acec4d7a10239fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e0d0095a0a5d4a2cf38b3f0fe17327"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a81e0d0095a0a5d4a2cf38b3f0fe17327">PCD_Init</a> (uint8_t chipSelectPin, uint8_t resetPowerDownPin)</td></tr>
<tr class="memdesc:a81e0d0095a0a5d4a2cf38b3f0fe17327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> chip.  <a href="#a81e0d0095a0a5d4a2cf38b3f0fe17327">More...</a><br/></td></tr>
<tr class="separator:a81e0d0095a0a5d4a2cf38b3f0fe17327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa627ac387b7b81a55eb65d69f0d6cd51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#aa627ac387b7b81a55eb65d69f0d6cd51">PCD_Reset</a> ()</td></tr>
<tr class="memdesc:aa627ac387b7b81a55eb65d69f0d6cd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a soft reset on the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> chip and wait for it to be ready again.  <a href="#aa627ac387b7b81a55eb65d69f0d6cd51">More...</a><br/></td></tr>
<tr class="separator:aa627ac387b7b81a55eb65d69f0d6cd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf8022c74614356b2b0350570bac64d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a1bf8022c74614356b2b0350570bac64d">PCD_AntennaOn</a> ()</td></tr>
<tr class="memdesc:a1bf8022c74614356b2b0350570bac64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns the antenna on by enabling pins TX1 and TX2.  <a href="#a1bf8022c74614356b2b0350570bac64d">More...</a><br/></td></tr>
<tr class="separator:a1bf8022c74614356b2b0350570bac64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec04dca980c7cfcad234fb74f241369"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a1ec04dca980c7cfcad234fb74f241369">PCD_AntennaOff</a> ()</td></tr>
<tr class="memdesc:a1ec04dca980c7cfcad234fb74f241369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns the antenna off by disabling pins TX1 and TX2.  <a href="#a1ec04dca980c7cfcad234fb74f241369">More...</a><br/></td></tr>
<tr class="separator:a1ec04dca980c7cfcad234fb74f241369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bd31a2011cb66ebd99f660ba7b5d69"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a60bd31a2011cb66ebd99f660ba7b5d69">PCD_GetAntennaGain</a> ()</td></tr>
<tr class="memdesc:a60bd31a2011cb66ebd99f660ba7b5d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> Receiver Gain (RxGain[2:0]) value.  <a href="#a60bd31a2011cb66ebd99f660ba7b5d69">More...</a><br/></td></tr>
<tr class="separator:a60bd31a2011cb66ebd99f660ba7b5d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ead771fb7925af374f84962a1b118f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a81ead771fb7925af374f84962a1b118f">PCD_SetAntennaGain</a> (uint8_t mask)</td></tr>
<tr class="memdesc:a81ead771fb7925af374f84962a1b118f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> Receiver Gain (RxGain) to value specified by given mask.  <a href="#a81ead771fb7925af374f84962a1b118f">More...</a><br/></td></tr>
<tr class="separator:a81ead771fb7925af374f84962a1b118f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1408fd1b9df3230f04609515ae28780a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a1408fd1b9df3230f04609515ae28780a">PCD_PerformSelfTest</a> ()</td></tr>
<tr class="memdesc:a1408fd1b9df3230f04609515ae28780a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a self-test of the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> See 16.1.1 in <a href="http://www.nxp.com/documents/data_sheet/MFRC522.pdf">http://www.nxp.com/documents/data_sheet/MFRC522.pdf</a>.  <a href="#a1408fd1b9df3230f04609515ae28780a">More...</a><br/></td></tr>
<tr class="separator:a1408fd1b9df3230f04609515ae28780a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa8197345d434273f673318abba1d0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#aaaa8197345d434273f673318abba1d0f">PCD_SoftPowerDown</a> ()</td></tr>
<tr class="separator:aaaa8197345d434273f673318abba1d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5785a1ab77bfef495a18b8be64d716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#abc5785a1ab77bfef495a18b8be64d716">PCD_SoftPowerUp</a> ()</td></tr>
<tr class="separator:abc5785a1ab77bfef495a18b8be64d716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3e7879913ba9db625c715a538e5155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#aec3e7879913ba9db625c715a538e5155">PCD_TransceiveData</a> (uint8_t *sendData, uint8_t sendLen, uint8_t *backData, uint8_t *backLen, uint8_t *validBits=nullptr, uint8_t rxAlign=0, bool checkCRC=false)</td></tr>
<tr class="memdesc:aec3e7879913ba9db625c715a538e5155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Transceive command.  <a href="#aec3e7879913ba9db625c715a538e5155">More...</a><br/></td></tr>
<tr class="separator:aec3e7879913ba9db625c715a538e5155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fee5d1bf21991422badc312152c49a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a59fee5d1bf21991422badc312152c49a">PCD_CommunicateWithPICC</a> (uint8_t command, uint8_t waitIRq, uint8_t *sendData, uint8_t sendLen, uint8_t *backData=nullptr, uint8_t *backLen=nullptr, uint8_t *validBits=nullptr, uint8_t rxAlign=0, bool checkCRC=false)</td></tr>
<tr class="memdesc:a59fee5d1bf21991422badc312152c49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers data to the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> FIFO, executes a command, waits for completion and transfers data back from the FIFO.  <a href="#a59fee5d1bf21991422badc312152c49a">More...</a><br/></td></tr>
<tr class="separator:a59fee5d1bf21991422badc312152c49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6e40cb3c6b57a699a623bd09d859fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a4f6e40cb3c6b57a699a623bd09d859fc">PICC_RequestA</a> (uint8_t *bufferATQA, uint8_t *bufferSize)</td></tr>
<tr class="memdesc:a4f6e40cb3c6b57a699a623bd09d859fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits a REQuest command, Type A.  <a href="#a4f6e40cb3c6b57a699a623bd09d859fc">More...</a><br/></td></tr>
<tr class="separator:a4f6e40cb3c6b57a699a623bd09d859fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414e7dd52abf129e38a3fd7502e0deda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a414e7dd52abf129e38a3fd7502e0deda">PICC_WakeupA</a> (uint8_t *bufferATQA, uint8_t *bufferSize)</td></tr>
<tr class="memdesc:a414e7dd52abf129e38a3fd7502e0deda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits a Wake-UP command, Type A.  <a href="#a414e7dd52abf129e38a3fd7502e0deda">More...</a><br/></td></tr>
<tr class="separator:a414e7dd52abf129e38a3fd7502e0deda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6f1dcbfede41160cc84085b08c2fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a6d6f1dcbfede41160cc84085b08c2fbe">PICC_REQA_or_WUPA</a> (uint8_t command, uint8_t *bufferATQA, uint8_t *bufferSize)</td></tr>
<tr class="memdesc:a6d6f1dcbfede41160cc84085b08c2fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits REQA or WUPA commands.  <a href="#a6d6f1dcbfede41160cc84085b08c2fbe">More...</a><br/></td></tr>
<tr class="separator:a6d6f1dcbfede41160cc84085b08c2fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e85af574de32cd21c41fa6de7bbdff5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a0e85af574de32cd21c41fa6de7bbdff5">PICC_Select</a> (<a class="el" href="struct_m_f_r_c_1_1_uid.html">Uid</a> *<a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#ad8de0e182e9997bf618c2781f3d76d73">uid</a>, uint8_t validBits=0)</td></tr>
<tr class="memdesc:a0e85af574de32cd21c41fa6de7bbdff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits SELECT/ANTICOLLISION commands to select a single PICC.  <a href="#a0e85af574de32cd21c41fa6de7bbdff5">More...</a><br/></td></tr>
<tr class="separator:a0e85af574de32cd21c41fa6de7bbdff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33ab087fb7cb1fc34042f8289344ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#aa33ab087fb7cb1fc34042f8289344ac0">PICC_HaltA</a> ()</td></tr>
<tr class="memdesc:aa33ab087fb7cb1fc34042f8289344ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instructs a PICC in state ACTIVE(*) to go to state HALT.  <a href="#aa33ab087fb7cb1fc34042f8289344ac0">More...</a><br/></td></tr>
<tr class="separator:aa33ab087fb7cb1fc34042f8289344ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921dc080403ef79a61261cc0f6a6b6fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a921dc080403ef79a61261cc0f6a6b6fe">PCD_Authenticate</a> (uint8_t command, uint8_t blockAddr, MIFARE_Key *key, <a class="el" href="struct_m_f_r_c_1_1_uid.html">Uid</a> *<a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#ad8de0e182e9997bf618c2781f3d76d73">uid</a>)</td></tr>
<tr class="memdesc:a921dc080403ef79a61261cc0f6a6b6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> MFAuthent command.  <a href="#a921dc080403ef79a61261cc0f6a6b6fe">More...</a><br/></td></tr>
<tr class="separator:a921dc080403ef79a61261cc0f6a6b6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca1a078d263e61a1416ecab8bb2ac13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#acca1a078d263e61a1416ecab8bb2ac13">PCD_StopCrypto1</a> ()</td></tr>
<tr class="memdesc:acca1a078d263e61a1416ecab8bb2ac13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to exit the PCD from its authenticated state.  <a href="#acca1a078d263e61a1416ecab8bb2ac13">More...</a><br/></td></tr>
<tr class="separator:acca1a078d263e61a1416ecab8bb2ac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65521bb114da2206e265883bc3064b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#ac65521bb114da2206e265883bc3064b9">MIFARE_Read</a> (uint8_t blockAddr, uint8_t *buffer, uint8_t *bufferSize)</td></tr>
<tr class="memdesc:ac65521bb114da2206e265883bc3064b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 16 bytes (+ 2 bytes CRC_A) from the active PICC.  <a href="#ac65521bb114da2206e265883bc3064b9">More...</a><br/></td></tr>
<tr class="separator:ac65521bb114da2206e265883bc3064b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b19e0ca30b6915bef16a32c406cba8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a80b19e0ca30b6915bef16a32c406cba8">MIFARE_Write</a> (uint8_t blockAddr, uint8_t *buffer, uint8_t bufferSize)</td></tr>
<tr class="memdesc:a80b19e0ca30b6915bef16a32c406cba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes 16 bytes to the active PICC.  <a href="#a80b19e0ca30b6915bef16a32c406cba8">More...</a><br/></td></tr>
<tr class="separator:a80b19e0ca30b6915bef16a32c406cba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adf9557f47064a58263679330cea7f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a6adf9557f47064a58263679330cea7f7">MIFARE_Ultralight_Write</a> (uint8_t page, uint8_t *buffer, uint8_t bufferSize)</td></tr>
<tr class="memdesc:a6adf9557f47064a58263679330cea7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a 4 byte page to the active MIFARE Ultralight PICC.  <a href="#a6adf9557f47064a58263679330cea7f7">More...</a><br/></td></tr>
<tr class="separator:a6adf9557f47064a58263679330cea7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d7c4b94601999952124bb5961de535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#ac5d7c4b94601999952124bb5961de535">MIFARE_Decrement</a> (uint8_t blockAddr, int32_t delta)</td></tr>
<tr class="memdesc:ac5d7c4b94601999952124bb5961de535"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIFARE Decrement subtracts the delta from the value of the addressed block, and stores the result in a volatile memory.  <a href="#ac5d7c4b94601999952124bb5961de535">More...</a><br/></td></tr>
<tr class="separator:ac5d7c4b94601999952124bb5961de535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7558f6f0e2eb1ec951db6cefbef582cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a7558f6f0e2eb1ec951db6cefbef582cb">MIFARE_Increment</a> (uint8_t blockAddr, int32_t delta)</td></tr>
<tr class="memdesc:a7558f6f0e2eb1ec951db6cefbef582cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIFARE Increment adds the delta to the value of the addressed block, and stores the result in a volatile memory.  <a href="#a7558f6f0e2eb1ec951db6cefbef582cb">More...</a><br/></td></tr>
<tr class="separator:a7558f6f0e2eb1ec951db6cefbef582cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f89901ec82b5b953703d9024b7b15b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#ad5f89901ec82b5b953703d9024b7b15b">MIFARE_Restore</a> (uint8_t blockAddr)</td></tr>
<tr class="memdesc:ad5f89901ec82b5b953703d9024b7b15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIFARE Restore copies the value of the addressed block into a volatile memory.  <a href="#ad5f89901ec82b5b953703d9024b7b15b">More...</a><br/></td></tr>
<tr class="separator:ad5f89901ec82b5b953703d9024b7b15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d462097146d6675f85bc51883eb6669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a0d462097146d6675f85bc51883eb6669">MIFARE_Transfer</a> (uint8_t blockAddr)</td></tr>
<tr class="memdesc:a0d462097146d6675f85bc51883eb6669"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIFARE Transfer writes the value stored in the volatile memory into one MIFARE Classic block.  <a href="#a0d462097146d6675f85bc51883eb6669">More...</a><br/></td></tr>
<tr class="separator:a0d462097146d6675f85bc51883eb6669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb344afd8234f3e0a845e1f0ceb6488"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a0bb344afd8234f3e0a845e1f0ceb6488">MIFARE_GetValue</a> (uint8_t blockAddr, int32_t *value)</td></tr>
<tr class="memdesc:a0bb344afd8234f3e0a845e1f0ceb6488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper routine to read the current value from a Value Block.  <a href="#a0bb344afd8234f3e0a845e1f0ceb6488">More...</a><br/></td></tr>
<tr class="separator:a0bb344afd8234f3e0a845e1f0ceb6488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8ea41dc9a828d2a1f01b0d03d4e21b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a1b8ea41dc9a828d2a1f01b0d03d4e21b">MIFARE_SetValue</a> (uint8_t blockAddr, int32_t value)</td></tr>
<tr class="memdesc:a1b8ea41dc9a828d2a1f01b0d03d4e21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper routine to write a specific value into a Value Block.  <a href="#a1b8ea41dc9a828d2a1f01b0d03d4e21b">More...</a><br/></td></tr>
<tr class="separator:a1b8ea41dc9a828d2a1f01b0d03d4e21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7789da2100091438b9ede0a73f50c2e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a7789da2100091438b9ede0a73f50c2e3">PCD_NTAG216_AUTH</a> (uint8_t *passWord, uint8_t pACK[])</td></tr>
<tr class="memdesc:a7789da2100091438b9ede0a73f50c2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Authenticate with a NTAG216.  <a href="#a7789da2100091438b9ede0a73f50c2e3">More...</a><br/></td></tr>
<tr class="separator:a7789da2100091438b9ede0a73f50c2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31854b1a3968b9f91f90abd71e46cd55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a31854b1a3968b9f91f90abd71e46cd55">PCD_MIFARE_Transceive</a> (uint8_t *sendData, uint8_t sendLen, bool acceptTimeout=false)</td></tr>
<tr class="memdesc:a31854b1a3968b9f91f90abd71e46cd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for MIFARE protocol communication.  <a href="#a31854b1a3968b9f91f90abd71e46cd55">More...</a><br/></td></tr>
<tr class="separator:a31854b1a3968b9f91f90abd71e46cd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf9aa924afb6a23a35ed5beb1d9039e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a57b98d38ff9e306540e228a822dffcf3">PICC_Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a2cf9aa924afb6a23a35ed5beb1d9039e">PICC_GetType</a> (uint8_t sak)</td></tr>
<tr class="memdesc:a2cf9aa924afb6a23a35ed5beb1d9039e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates the SAK (Select Acknowledge) to a PICC type.  <a href="#a2cf9aa924afb6a23a35ed5beb1d9039e">More...</a><br/></td></tr>
<tr class="separator:a2cf9aa924afb6a23a35ed5beb1d9039e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705ed68b27893cd174638415d3a65e94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a705ed68b27893cd174638415d3a65e94">MIFARE_SetAccessBits</a> (uint8_t *accessBitBuffer, uint8_t g0, uint8_t g1, uint8_t g2, uint8_t g3)</td></tr>
<tr class="memdesc:a705ed68b27893cd174638415d3a65e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the bit pattern needed for the specified access bits.  <a href="#a705ed68b27893cd174638415d3a65e94">More...</a><br/></td></tr>
<tr class="separator:a705ed68b27893cd174638415d3a65e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad8de0e182e9997bf618c2781f3d76d73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_m_f_r_c_1_1_uid.html">Uid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#ad8de0e182e9997bf618c2781f3d76d73">uid</a></td></tr>
<tr class="separator:ad8de0e182e9997bf618c2781f3d76d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa7ca9492ee1ddcda650310dc07961714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#aa7ca9492ee1ddcda650310dc07961714">MIFARE_TwoStepHelper</a> (uint8_t command, uint8_t blockAddr, int32_t data)</td></tr>
<tr class="memdesc:aa7ca9492ee1ddcda650310dc07961714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for the two-step MIFARE Classic protocol operations Decrement, Increment and Restore.  <a href="#aa7ca9492ee1ddcda650310dc07961714">More...</a><br/></td></tr>
<tr class="separator:aa7ca9492ee1ddcda650310dc07961714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1839f9049091b1c113ad4432768ac39e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a1839f9049091b1c113ad4432768ac39e">readReg</a> (uint8_t reg)</td></tr>
<tr class="memdesc:a1839f9049091b1c113ad4432768ac39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically convert the given register address to be recognized as a readable location.  <a href="#a1839f9049091b1c113ad4432768ac39e">More...</a><br/></td></tr>
<tr class="separator:a1839f9049091b1c113ad4432768ac39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72247c04ebbe81567957d859de31c46"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#af72247c04ebbe81567957d859de31c46">writeReg</a> (uint8_t reg)</td></tr>
<tr class="memdesc:af72247c04ebbe81567957d859de31c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically convert the given register address to be recognized as a writable location.  <a href="#af72247c04ebbe81567957d859de31c46">More...</a><br/></td></tr>
<tr class="separator:af72247c04ebbe81567957d859de31c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2e840a158b013e104751894b18493b59"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a2e840a158b013e104751894b18493b59">_chipSelectPin</a></td></tr>
<tr class="separator:a2e840a158b013e104751894b18493b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed43235e1d1b3f809af2af4fb654d34"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#abed43235e1d1b3f809af2af4fb654d34">_resetPowerDownPin</a></td></tr>
<tr class="separator:abed43235e1d1b3f809af2af4fb654d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b046e1eecb7fad75ab50afa194d0b7"><td class="memItemLeft" align="right" valign="top">SPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a17b046e1eecb7fad75ab50afa194d0b7">device</a></td></tr>
<tr class="separator:a17b046e1eecb7fad75ab50afa194d0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ae9019c333bc5837f98d187344336c"><td class="memItemLeft" align="right" valign="top">const SPISettings&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#aa9ae9019c333bc5837f98d187344336c">_spiSettings</a></td></tr>
<tr class="separator:aa9ae9019c333bc5837f98d187344336c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class SPI&gt;<br/>
class MFRC::MFRC522&lt; SPI &gt;</h3>


<p>Definition at line <a class="el" href="_m_f_r_c522_8hpp_source.html#l00167">167</a> of file <a class="el" href="_m_f_r_c522_8hpp_source.html">MFRC522.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a297921e5955751817b53b95b34b23d63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::<a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>chipSelectPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>resetPowerDownPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SPI&#160;</td>
          <td class="paramname"><em>spiClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SPISettings&#160;</td>
          <td class="paramname"><em>spiSettings</em> = <code>SPISettings(SPI_CLOCK_DIV4,&#160;MSBFIRST,&#160;SPI_MODE0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_m_f_r_c522_8hpp_source.html#l00172">172</a> of file <a class="el" href="_m_f_r_c522_8hpp_source.html">MFRC522.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c5c7485784b98763c33e7da9d2f7c62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::<a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_m_f_r_c522_8hpp_source.html#l00176">176</a> of file <a class="el" href="_m_f_r_c522_8hpp_source.html">MFRC522.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac5d7c4b94601999952124bb5961de535"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::MIFARE_Decrement </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MIFARE Decrement subtracts the delta from the value of the addressed block, and stores the result in a volatile memory. </p>
<p>For MIFARE Classic only. The sector containing the block must be authenticated before calling this function. Only for blocks in "value block" mode, ie with access bits [C1 C2 C3] = [110] or [001]. Use <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a0d462097146d6675f85bc51883eb6669" title="MIFARE Transfer writes the value stored in the volatile memory into one MIFARE Classic block...">MIFARE_Transfer()</a> to store the result in a block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockAddr</td><td>The block number </td></tr>
    <tr><td class="paramname">delta</td><td>The number to subtract from the value of the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00801">801</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0bb344afd8234f3e0a845e1f0ceb6488"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::MIFARE_GetValue </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper routine to read the current value from a Value Block. </p>
<p>Only for MIFARE Classic and only for blocks in "value block" mode, that is: with access bits [C1 C2 C3] = [110] or [001]. The sector containing the block must be authenticated before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blockAddr</td><td>The block (0x00-0xff) number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Current value of the Value Block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00862">862</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7558f6f0e2eb1ec951db6cefbef582cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::MIFARE_Increment </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MIFARE Increment adds the delta to the value of the addressed block, and stores the result in a volatile memory. </p>
<p>For MIFARE Classic only. The sector containing the block must be authenticated before calling this function. Only for blocks in "value block" mode, ie with access bits [C1 C2 C3] = [110] or [001]. Use <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a0d462097146d6675f85bc51883eb6669" title="MIFARE Transfer writes the value stored in the volatile memory into one MIFARE Classic block...">MIFARE_Transfer()</a> to store the result in a block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockAddr</td><td>The block number </td></tr>
    <tr><td class="paramname">delta</td><td>The number to subtract from the value of the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00806">806</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac65521bb114da2206e265883bc3064b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRC522::StatusCode <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::MIFARE_Read </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads 16 bytes (+ 2 bytes CRC_A) from the active PICC. </p>
<p>For MIFARE Classic the sector containing the block must be authenticated before calling this function.</p>
<p>For MIFARE Ultralight only addresses 00h to 0Fh are decoded. The MF0ICU1 returns a NAK for higher addresses. The MF0ICU1 responds to the READ command by sending 16 bytes starting from the page address defined by the command argument. For example; if blockAddr is 03h then pages 03h, 04h, 05h, 06h are returned. A roll-back is implemented: If blockAddr is 0Eh, then the contents of pages 0Eh, 0Fh, 00h and 01h are returned.</p>
<p>The buffer must be at least 18 bytes because a CRC_A is also returned. Checks the CRC_A before returning STATUS_OK.</p>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockAddr</td><td>MIFARE Classic: The block (0-0xff) number. MIFARE Ultralight: The first page to return data from. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to store the data in </td></tr>
    <tr><td class="paramname">bufferSize</td><td>Buffer size, at least 18 bytes. Also number of bytes returned if STATUS_OK. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00713">713</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5f89901ec82b5b953703d9024b7b15b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::MIFARE_Restore </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MIFARE Restore copies the value of the addressed block into a volatile memory. </p>
<p>For MIFARE Classic only. The sector containing the block must be authenticated before calling this function. Only for blocks in "value block" mode, ie with access bits [C1 C2 C3] = [110] or [001]. Use <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a0d462097146d6675f85bc51883eb6669" title="MIFARE Transfer writes the value stored in the volatile memory into one MIFARE Classic block...">MIFARE_Transfer()</a> to store the result in a block.</p>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00811">811</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a705ed68b27893cd174638415d3a65e94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::MIFARE_SetAccessBits </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>accessBitBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>g0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>g3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the bit pattern needed for the specified access bits. </p>
<p>In the [C1 C2 C3] tuples C1 is MSB (=4) and C3 is LSB (=1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accessBitBuffer</td><td>Pointer to byte 6, 7 and 8 in the sector trailer. Bytes [0..2] will be set. </td></tr>
    <tr><td class="paramname">g0</td><td>Access bits [C1 C2 C3] for block 0 (for sectors 0-31) or blocks 0-4 (for sectors 32-39) </td></tr>
    <tr><td class="paramname">g1</td><td>Access bits C1 C2 C3] for block 1 (for sectors 0-31) or blocks 5-9 (for sectors 32-39) </td></tr>
    <tr><td class="paramname">g2</td><td>Access bits C1 C2 C3] for block 2 (for sectors 0-31) or blocks 10-14 (for sectors 32-39) </td></tr>
    <tr><td class="paramname">g3</td><td>Access bits C1 C2 C3] for the sector trailer, block 3 (for sectors 0-31) or block 15 (for sectors 32-39) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00996">996</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1b8ea41dc9a828d2a1f01b0d03d4e21b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::MIFARE_SetValue </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper routine to write a specific value into a Value Block. </p>
<p>Only for MIFARE Classic and only for blocks in "value block" mode, that is: with access bits [C1 C2 C3] = [110] or [001]. The sector containing the block must be authenticated before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blockAddr</td><td>The block (0x00-0xff) number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>New value of the Value Block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00877">877</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0d462097146d6675f85bc51883eb6669"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::MIFARE_Transfer </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MIFARE Transfer writes the value stored in the volatile memory into one MIFARE Classic block. </p>
<p>For MIFARE Classic only. The sector containing the block must be authenticated before calling this function. Only for blocks in "value block" mode, ie with access bits [C1 C2 C3] = [110] or [001].</p>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00847">847</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7ca9492ee1ddcda650310dc07961714"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::MIFARE_TwoStepHelper </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for the two-step MIFARE Classic protocol operations Decrement, Increment and Restore. </p>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command to use </td></tr>
    <tr><td class="paramname">blockAddr</td><td>The block (0-0xff) number. </td></tr>
    <tr><td class="paramname">data</td><td>The data to transfer in step 2 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00823">823</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6adf9557f47064a58263679330cea7f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::MIFARE_Ultralight_Write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a 4 byte page to the active MIFARE Ultralight PICC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>page (2-15) to write to. </td></tr>
    <tr><td class="paramname">the</td><td>4 bytes to write </td></tr>
    <tr><td class="paramname">Buffer</td><td>size, must be at least 4 bytes. Exactly 4 bytes are written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00778">778</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80b19e0ca30b6915bef16a32c406cba8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRC522::StatusCode <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::MIFARE_Write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes 16 bytes to the active PICC. </p>
<p>For MIFARE Classic the sector containing the block must be authenticated before calling this function.</p>
<p>For MIFARE Ultralight the operation is called "COMPATIBILITY WRITE". Even though 16 bytes are transferred to the Ultralight PICC, only the least significant 4 bytes (bytes 0 to 3) are written to the specified address. It is recommended to set the remaining bytes 04h to 0Fh to all logic 0.</p>
<ul>
<li><dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockAddr</td><td>MIFARE Classic: The block (0-0xff) number. MIFARE Ultralight: The page (2-15) to write to. </td></tr>
    <tr><td class="paramname">buffer</td><td>The 16 bytes to write to the PICC </td></tr>
    <tr><td class="paramname">bufferSize</td><td>Buffer size, must be at least 16 bytes. Exactly 16 bytes are written. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00748">748</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ec04dca980c7cfcad234fb74f241369"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_AntennaOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns the antenna off by disabling pins TX1 and TX2. </p>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00173">173</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1bf8022c74614356b2b0350570bac64d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_AntennaOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns the antenna on by enabling pins TX1 and TX2. </p>
<p>After a reset these pins are disabled. </p>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00165">165</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a921dc080403ef79a61261cc0f6a6b6fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRC522::StatusCode <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_Authenticate </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MIFARE_Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_f_r_c_1_1_uid.html">Uid</a> *&#160;</td>
          <td class="paramname"><em>uid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> MFAuthent command. </p>
<p>This command manages MIFARE authentication to enable a secure communication to any MIFARE Mini, MIFARE 1K and MIFARE 4K card. The authentication is described in the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> datasheet section 10.3.1.9 and <a href="http://www.nxp.com/documents/data_sheet/MF1S503x.pdf">http://www.nxp.com/documents/data_sheet/MF1S503x.pdf</a> section 10.1. For use with MIFARE Classic PICCs. The PICC must be selected - ie in state ACTIVE(*) - before calling this function. Remember to call <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#acca1a078d263e61a1416ecab8bb2ac13" title="Used to exit the PCD from its authenticated state. ">PCD_StopCrypto1()</a> after communicating with the authenticated PICC - otherwise no new communications can start.</p>
<p>All keys are set to FFFFFFFFFFFFh at chip delivery.</p>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. Probably STATUS_TIMEOUT if you supply the wrong key. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>PICC_CMD_MF_AUTH_KEY_A or PICC_CMD_MF_AUTH_KEY_B </td></tr>
    <tr><td class="paramname">blockAddr</td><td>The block number. See numbering in the comments in the .h file. </td></tr>
    <tr><td class="paramname">key</td><td>Pointer to the Crypteo1 key to use (6 bytes) </td></tr>
    <tr><td class="paramname">uid</td><td>Pointer to <a class="el" href="struct_m_f_r_c_1_1_uid.html">Uid</a> struct. The first 4 bytes of the UID is used. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00665">665</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1993a4ebe1f303f2ade7ca51da3e6771"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_CalculateCRC </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the CRC coprocessor in the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> to calculate a CRC_A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the data to transfer to the FIFO for CRC calculation. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to transfer. </td></tr>
    <tr><td class="paramname">result</td><td>Pointer to the result buffer. Result is written to result[0..1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_TIMEOUT otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00073">73</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa4b4606785e6d0fac5de0b7c5c33634b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_ClearRegisterBitMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_m_f_r_c.html#a2da467e59aa8c879edcc6aa3c9209638">PCDRegister</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the bits given in mask from register reg. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The register that will be updated. </td></tr>
    <tr><td class="paramname">mask</td><td>The bitmask that will be cleared from reg. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00066">66</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59fee5d1bf21991422badc312152c49a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_CommunicateWithPICC </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>waitIRq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sendLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>backData</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>backLen</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>validBits</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rxAlign</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkCRC</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfers data to the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> FIFO, executes a command, waits for completion and transfers data back from the FIFO. </p>
<p>CRC validation can only be done if backData and backLen are specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command to execute. One of the PCD_Command enums. </td></tr>
    <tr><td class="paramname">waitIRq</td><td>The bits in the ComIrqReg register that signals successful completion of the command. </td></tr>
    <tr><td class="paramname">sendData</td><td>Pointer to the data to transfer to the FIFO. </td></tr>
    <tr><td class="paramname">sendLen</td><td>Number of bytes to transfer to the FIFO. </td></tr>
    <tr><td class="paramname">backData</td><td>nullptr or pointer to buffer if data should be read back after executing the command. </td></tr>
    <tr><td class="paramname">backLen</td><td>In: Max number of bytes to write to *backData. Out: The number of bytes returned. </td></tr>
    <tr><td class="paramname">validBits</td><td>In/Out: The number of valid bits in the last byte. 0 for 8 valid bits. </td></tr>
    <tr><td class="paramname">rxAlign</td><td>In: Defines the bit position in backData[0] for the first bit received. Default 0. </td></tr>
    <tr><td class="paramname">checkCRC</td><td>In: True =&gt; The last two bytes of the response is assumed to be a CRC_A that must be validated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00303">303</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60bd31a2011cb66ebd99f660ba7b5d69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_GetAntennaGain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> Receiver Gain (RxGain[2:0]) value. </p>
<p>See 9.3.3.6 / table 98 in <a href="http://www.nxp.com/documents/data_sheet/MFRC522.pdf">http://www.nxp.com/documents/data_sheet/MFRC522.pdf</a> NOTE: Return value scrubbed with (0x07&lt;&lt;4)=01110000b as RCFfgReg may use reserved bits.</p>
<dl class="section return"><dt>Returns</dt><dd>Value of the RxGain, scrubbed to the 3 bits used. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00178">178</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7977fc7aca1707b43acec4d7a10239fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> chip. </p>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00100">100</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a81e0d0095a0a5d4a2cf38b3f0fe17327"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_Init </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>chipSelectPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>resetPowerDownPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> chip. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chipSelectPin</td><td>Arduino pin connected to <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a>'s SPI slave select input (Pin 24, NSS, active low) </td></tr>
    <tr><td class="paramname">resetPowerDownPin</td><td>Arduino pin connected to <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a>'s reset and power down input (Pin 6, NRSTPD, active low) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00144">144</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a31854b1a3968b9f91f90abd71e46cd55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_MIFARE_Transceive </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sendLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acceptTimeout</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for MIFARE protocol communication. </p>
<p>Adds CRC_A, executes the Transceive command and checks that the response is MF_ACK or a timeout. ///&lt; Pointer to the data to transfer to the FIFO. Do NOT include the CRC_A. ///&lt; Number of bytes in sendData. ///&lt; True =&gt; A timeout is also success</p>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00935">935</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7789da2100091438b9ede0a73f50c2e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_NTAG216_AUTH </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>passWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pACK</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Authenticate with a NTAG216. </p>
<p>Only for NTAG216. First implemented by Gargantuanman.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">passWord</td><td>password. </td></tr>
    <tr><td class="paramname">pACK</td><td>result success???. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00899">899</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1408fd1b9df3230f04609515ae28780a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_PerformSelfTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a self-test of the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> See 16.1.1 in <a href="http://www.nxp.com/documents/data_sheet/MFRC522.pdf">http://www.nxp.com/documents/data_sheet/MFRC522.pdf</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the test passed. Or false if no firmware reference is available. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00191">191</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a31a393a1dff186ad19d31f9e02ee4e78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_ReadRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_m_f_r_c.html#a2da467e59aa8c879edcc6aa3c9209638">PCDRegister</a>&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a byte from the specified register in the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> chip. </p>
<p>The interface is described in the datasheet section 8.1.2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The register to read from. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00022">22</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9649953537c252a9572b8d843c3646ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_ReadRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_m_f_r_c.html#a2da467e59aa8c879edcc6aa3c9209638">PCDRegister</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rxAlign</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a number of bytes from the specified register in the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> chip. </p>
<p>The interface is described in the datasheet section 8.1.2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The register to read from. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to read </td></tr>
    <tr><td class="paramname">values</td><td>Byte array to store the values in </td></tr>
    <tr><td class="paramname">rxAlign</td><td>Specify which bit positions to update. Only rxAlign..7 in values[0] are updated. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00032">32</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa627ac387b7b81a55eb65d69f0d6cd51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a soft reset on the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> chip and wait for it to be ready again. </p>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00152">152</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a81ead771fb7925af374f84962a1b118f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_SetAntennaGain </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> Receiver Gain (RxGain) to value specified by given mask. </p>
<p>See 9.3.3.6 / table 98 in <a href="http://www.nxp.com/documents/data_sheet/MFRC522.pdf">http://www.nxp.com/documents/data_sheet/MFRC522.pdf</a> NOTE: Given mask is scrubbed with (0x07&lt;&lt;4)=01110000b as RCFfgReg may use reserved bits. </p>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00183">183</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae67c3d632e2cd9f02c79d5ab04e3b6d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_SetRegisterBitMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_m_f_r_c.html#a2da467e59aa8c879edcc6aa3c9209638">PCDRegister</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a bitwise OR on the given register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The register to update. </td></tr>
    <tr><td class="paramname">mask</td><td>The bitwise OR mask to update the register. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00059">59</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaaa8197345d434273f673318abba1d0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_SoftPowerDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00273">273</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc5785a1ab77bfef495a18b8be64d716"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_SoftPowerUp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00281">281</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acca1a078d263e61a1416ecab8bb2ac13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_StopCrypto1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to exit the PCD from its authenticated state. </p>
<p>Remember to call this function after communicating with an authenticated PICC - otherwise no new communications can start. </p>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00691">691</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec3e7879913ba9db625c715a538e5155"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_TransceiveData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sendLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>backData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>backLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>validBits</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rxAlign</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkCRC</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Transceive command. </p>
<p>CRC validation can only be done if backData and backLen are specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendData</td><td>Pointer to the data to transfer to the FIFO. </td></tr>
    <tr><td class="paramname">sendLen</td><td>Number of bytes to transfer to the FIFO. </td></tr>
    <tr><td class="paramname">backData</td><td>nullptr or pointer to buffer if data should be read back after executing the command. </td></tr>
    <tr><td class="paramname">backLen</td><td>In: Max number of bytes to write to *backData. Out: The number of bytes returned. </td></tr>
    <tr><td class="paramname">validBits</td><td>In/Out: The number of valid bits in the last byte. 0 for 8 valid bits. Default nullptr. </td></tr>
    <tr><td class="paramname">rxAlign</td><td>In: Defines the bit position in backData[0] for the first bit received. Default 0. </td></tr>
    <tr><td class="paramname">checkCRC</td><td>In: True =&gt; The last two bytes of the response is assumed to be a CRC_A that must be validated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00297">297</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6be478d423220af7b54db63c362a6902"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_WriteRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_m_f_r_c.html#a2da467e59aa8c879edcc6aa3c9209638">PCDRegister</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a byte to the specified register in the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> chip. </p>
<p>The interface is described in the datasheet section 8.1.2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The register to write to. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00004">4</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a087518df749ac13980f1b7aa075350d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PCD_WriteRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_m_f_r_c.html#a2da467e59aa8c879edcc6aa3c9209638">PCDRegister</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a number of bytes to the specified register in the <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a> chip. </p>
<p>The interface is described in the datasheet section 8.1.2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The register to write to. One of the PCDRegister enums. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to write to the register. </td></tr>
    <tr><td class="paramname">values</td><td>The byte array to be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00012">12</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2cf9aa924afb6a23a35ed5beb1d9039e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a57b98d38ff9e306540e228a822dffcf3">PICC_Type</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PICC_GetType </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sak</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates the SAK (Select Acknowledge) to a PICC type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sak</td><td>The SAK byte returned from <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a0e85af574de32cd21c41fa6de7bbdff5" title="Transmits SELECT/ANTICOLLISION commands to select a single PICC. ">PICC_Select()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00974">974</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa33ab087fb7cb1fc34042f8289344ac0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PICC_HaltA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instructs a PICC in state ACTIVE(*) to go to state HALT. </p>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00625">625</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d6f1dcbfede41160cc84085b08c2fbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRC522::StatusCode <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PICC_REQA_or_WUPA </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bufferATQA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmits REQA or WUPA commands. </p>
<p>Beware: When two PICCs are in the field at the same time I often get STATUS_TIMEOUT - probably due do bad antenna design.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command to send PICC_CMD_REQA or PICC_CMD_WUPA </td></tr>
    <tr><td class="paramname">bufferATQA</td><td>The buffer to store the ATQA. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>The buffer size, at least 2 bytes. This is also the number of bytes returned if STATU_OK. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, the appropriate status otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00399">399</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f6e40cb3c6b57a699a623bd09d859fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PICC_RequestA </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bufferATQA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmits a REQuest command, Type A. </p>
<p>Invites PICCs in state IDLE to go to READY and prepare for anticollision or selection. 7 bit frame. Beware: When two PICCs are in the field at the same time I often get STATUS_TIMEOUT - probably due do bad antenna design.</p>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00389">389</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e85af574de32cd21c41fa6de7bbdff5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MFRC522::StatusCode <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PICC_Select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_f_r_c_1_1_uid.html">Uid</a> *&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>validBits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transmits SELECT/ANTICOLLISION commands to select a single PICC. </p>
<p>Before calling this function the PICCs must be placed in the READY(*) state by calling <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a4f6e40cb3c6b57a699a623bd09d859fc" title="Transmits a REQuest command, Type A. ">PICC_RequestA()</a> or <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html#a414e7dd52abf129e38a3fd7502e0deda" title="Transmits a Wake-UP command, Type A. ">PICC_WakeupA()</a>. On success:</p>
<ul>
<li>The chosen PICC is in state ACTIVE(*) and all other PICCs have returned to state IDLE/HALT. (Figure 7 of the ISO/IEC 14443-3 draft.)</li>
<li>The UID size and value of the chosen PICC is returned in *uid along with the SAK.</li>
</ul>
<p>A PICC UID consists of 4, 7 or 10 bytes. Only 4 bytes can be specified in a SELECT command, so for the longer UIDs two or three iterations are used: UID size Number of UID bytes Cascade levels Example of PICC ======== =================== ============== =============== single 4 1 MIFARE Classic double 7 2 MIFARE Ultralight triple 10 3 Not currently in use?</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">validBits</td><td>The number of known UID bits supplied in uid. If set, you must also supply uid-&gt;size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, STATUS_??? otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00419">419</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a414e7dd52abf129e38a3fd7502e0deda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_m_f_r_c.html#a72766ea6443003b5ca58e0f38dff2e7d">StatusCode</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::PICC_WakeupA </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bufferATQA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmits a Wake-UP command, Type A. </p>
<p>Invites PICCs in state IDLE and HALT to go to READY(*) and prepare for anticollision or selection. 7 bit frame. Beware: When two PICCs are in the field at the same time I often get STATUS_TIMEOUT - probably due do bad antenna design.</p>
<dl class="section return"><dt>Returns</dt><dd>STATUS_OK on success, the appropriate status otherwise. </dd></dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l00394">394</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1839f9049091b1c113ad4432768ac39e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::readReg </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Automatically convert the given register address to be recognized as a readable location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Register address to eventually be read. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l01008">1008</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af72247c04ebbe81567957d859de31c46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::writeReg </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Automatically convert the given register address to be recognized as a writable location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Register address to eventually be written to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_m_f_r_c522_8cpp_source.html#l01013">1013</a> of file <a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2e840a158b013e104751894b18493b59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::_chipSelectPin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_m_f_r_c522_8hpp_source.html#l00526">526</a> of file <a class="el" href="_m_f_r_c522_8hpp_source.html">MFRC522.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abed43235e1d1b3f809af2af4fb654d34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::_resetPowerDownPin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_m_f_r_c522_8hpp_source.html#l00527">527</a> of file <a class="el" href="_m_f_r_c522_8hpp_source.html">MFRC522.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9ae9019c333bc5837f98d187344336c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SPISettings <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::_spiSettings</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_m_f_r_c522_8hpp_source.html#l00531">531</a> of file <a class="el" href="_m_f_r_c522_8hpp_source.html">MFRC522.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a17b046e1eecb7fad75ab50afa194d0b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SPI <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::device</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_m_f_r_c522_8hpp_source.html#l00530">530</a> of file <a class="el" href="_m_f_r_c522_8hpp_source.html">MFRC522.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad8de0e182e9997bf618c2781f3d76d73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_m_f_r_c_1_1_uid.html">Uid</a> <a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC::MFRC522</a>&lt; SPI &gt;::uid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_m_f_r_c522_8hpp_source.html#l00170">170</a> of file <a class="el" href="_m_f_r_c522_8hpp_source.html">MFRC522.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_m_f_r_c522_8hpp_source.html">MFRC522.hpp</a></li>
<li><a class="el" href="_m_f_r_c522_8cpp_source.html">MFRC522.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_m_f_r_c.html">MFRC</a></li><li class="navelem"><a class="el" href="class_m_f_r_c_1_1_m_f_r_c522.html">MFRC522</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
